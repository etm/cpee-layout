<!--
  This file is part of cpee-layout.

  cpee-layout is free software: you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free Software
  Foundation, either version 3 of the License, or (at your option) any later
  version.

  cpee-layout is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  You should have received a copy of the GNU General Public License along with
  cpee-layout (file COPYING in the main directory). If not, see
  <http://www.gnu.org/licenses/>.
-->

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>CPEE Layout Test</title>

    <!-- libs, do not modify. When local than load local libs. -->
    <script type="text/javascript" src="https://cpee.org/js_libs/jquery.min.js"></script>
    <script type="text/javascript" src="https://cpee.org/js_libs/util.js"></script>


    <!-- modelling ui -->
    <script type="text/javascript" src="wfadaptor.js"></script>
    <script type="text/javascript" src="resources.js"></script>
    <script type="text/javascript" src="themes/base.js"></script>

    <link rel="stylesheet" href="wfadaptor.css" type="text/css"/>
    <link rel="stylesheet" href="resources-label.css" type="text/css"/>
    <link rel="stylesheet" href="resources-svg.css" type="text/css"/>

    <style>
      @font-face {
        font-family: adawaita-sans;
        src: url(AdwaitaSans-Regular.ttf);
      }
    </style>

    <!-- integration -->
    <script>
      var graph_highlight = null;

      $(document).ready(() => {
        $.ajax({
          method: 'GET',
          url: 'model.xml',
          success: (data) => {
            new WfAdaptor('themes/dataflow/theme.js',function(graphrealization){
              graphrealization.draw_labels = (max,labels,dimensions,striped) => {
                // highlight
                if (graph_highlight) {
                  graph_highlight_tasks.forEach((ele) => {
                    let er = $('g[element-id=' + ele + ']').attr('element-row');
                    styletext = 'svg rect[element-row="'+ er + '"], div.graphlast[element-row="'+ er + '"] {  fill: #' + graph_highlight_color + ' !important; background-color:  #' + graph_highlight_color + ' !important; } ';
                    $('head').append('<style type="text/css">' + styletext + '</style>');
                    scroll_into_view(ele);
                  })
                }

                // labels
                $('#graphcanvas').css('grid-row', '1/span ' + (max.row + 2));
                if (striped == true) {
                  if (!$('#graphgrid').hasClass('striped')) {
                    $('#graphgrid').addClass('striped');
                  }
                } else {
                  $('#graphgrid').removeClass('striped');
                }

                $('.labelsrow, #graphgrid .graphlast').remove();
                let tcolumns = [];
                let tcolumntype = {};
                let tcolumncount = {}

                const mapPoints = new Map();
                const tcolumnsvgs = {};
                const iconsize = 10;
                const space = 5;

                for (val of labels) {
                  if (val.label != "") {
                    for (col of val.label) {
                      if (!tcolumns.includes(col.column)) {
                        tcolumns.push(col.column);
                        tcolumncount[col.column] = 0;
                        tcolumnsvgs[col.column] = {};
                      }
                      if (tcolumntype[col.column] == undefined && col.type != undefined) {
                        tcolumntype[col.column] = col.type;
                      }
                      if (col.value != undefined) {
                        let pos = dimensions.height_shift/2 + dimensions.height * (val.row - 1) + (dimensions.height / 2);
                        let firstpos = dimensions.height_shift/2 + (dimensions.height / 2);

                        if (col.type == "resource") {
                          for (const [k, v] of Object.entries(col.value)) {
                            var p = { AR: v };
                            if (!mapPoints.has(k)) {
                              p.y0 = p.y0 == undefined ? pos : p.y0;
                              p.ymax = (p.ymax == undefined) ? p.y0 : p.ymax;
                            } else {
                              p.y0 = mapPoints.get(k).y0;
                              p.ymax = mapPoints.get(k).ymax;
                            }
                            mapPoints.set(k, p);
                          }

                          let tsvg = $X('<g xmlns="http://www.w3.org/2000/svg" class="resource-row" element-row="' + (val.row-1) + '"></g>');

                          var cx = space;
                          var count = 0;
                          for (const [k, p] of mapPoints) {
                            let firstAssignFlag = false;
                            p.x = cx;

                            // Including Triangle
                            if (k in col.value) {   // Define points for a triangle pointing to the right
                              let inner;

                              if (p.AR == "Read") {
                                inner = $X('<polygon xmlns="http://www.w3.org/2000/svg" resource-column="' + count + '" points="' + (p.x) + ',' + pos + ' ' + (p.x + iconsize) + ',' + (pos + iconsize/2) + ' ' + (p.x + iconsize) + ',' + (pos - iconsize/2) + '" class="resource-point read"></polygon>');
                                if (pos == p.y0) { firstAssignFlag = true; }
                              } else if (p.AR == "Assign") {    // Define points for a triangle pointing to the left
                                inner = $X('<polygon xmlns="http://www.w3.org/2000/svg" resource-column="' + count + '" points="' + (p.x + iconsize) + ',' + pos + ' ' + (p.x) + ',' + (pos + iconsize/2) + ' ' + (p.x) + ',' + (pos - iconsize/2) + '" class="resource-point write"></polygon>');
                              } else if (p.AR == "AssignRead") {
                                inner = $X('<circle xmlns="http://www.w3.org/2000/svg" resource-column="' + count + '" cx="' + (p.x + iconsize/2) + '" cy="' + pos + '" r="' + (iconsize / 2) + '" class="resource-point both"></circle>');
                              } else if (p.AR == "ReadAssign") {
                                inner = $X('<circle xmlns="http://www.w3.org/2000/svg" resource-column="' + count + '" cx="' + (p.x + iconsize/2) + '" cy="' + pos + '" r="' + (iconsize / 2) + '" class="resource-point both"></circle>');
                                if (pos == p.y0) { firstAssignFlag = true; }
                              }

                              // extend the bars
                              if (pos > p.ymax) {
                                p.ymax = pos;
                              }

                              inner.append($X('<text xmlns="http://www.w3.org/2000/svg"></text>').text(k));
                              tsvg.append(inner);
                            }

                            if (firstAssignFlag) {
                              // Additional logic and construction of another polygon for orange triangle pointing left in row 0
                              p.y0 -= (val.row-1) * dimensions.height;
                              if (tcolumnsvgs[col.column][1] == undefined) {
                                tcolumnsvgs[col.column][1] = $X('<g xmlns="http://www.w3.org/2000/svg" class="resource-row" element-row="' + 0 + '"></g>');
                              }
                              tcolumnsvgs[col.column][1].append($X('<polygon xmlns="http://www.w3.org/2000/svg" resource-column="' + count + '" points="' + (p.x + iconsize) + ',' + firstpos + ' ' + (p.x) + ',' + (firstpos + iconsize/2) + ' ' + (p.x) + ',' + (firstpos - iconsize/2) + '" class="resource-point write"></polygon>').append($X('<text xmlns="http://www.w3.org/2000/svg"></text>').text(k)));
                            }
                            cx += iconsize + space;
                            count += 1;
                          }

                          if (tsvg.children().length > 0) {
                            tcolumnsvgs[col.column][val.row] = tsvg;
                          }
                        } else {
                          tsvg = $X('<text class="label" element-id="' + val.element_id + '" x="' + space + '" y="' + (dimensions.height * val.row - dimensions.height_shift) + '" xmlns="http://www.w3.org/2000/svg"></text>')
                          tsvg.text(col.value);
                          tsvg.mouseover(function(ev){ manifestation.events.mouseover($(ev.currentTarget).attr('element-id')); });
                          tsvg.mouseout(function(ev){ manifestation.events.mouseout($(ev.currentTarget).attr('element-id')); });
                          tsvg.click(function(ev){ manifestation.events.click($(ev.currentTarget).attr('element-id'),ev); });
                          tcolumnsvgs[col.column][val.row] = tsvg;
                        }

                        tcolumncount[col.column] += 1;
                      }
                    };
                  }
                };

                $('#graphgrid').css({
                  'grid-template-rows': (dimensions.height_shift/2) + 'px repeat(' + max.row + ', 1fr) ' + (dimensions.height_shift/2) + 'px',
                  'grid-template-columns': 'max-content' + (tcolumns.length > 0 ? ' repeat(' + tcolumns.length.toString() + ',max-content)' : '') + ' auto'
                });

                tcolumns.forEach(h => {
                  if (Object.keys(tcolumnsvgs[h]).length > 0) {
                    const svgcolumn = $X('<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink" class="labelsrow"></svg>');
                    const svgback = $X('<g xmlns="http://www.w3.org/2000/svg"></g>');
                    const svgfront = $X('<g xmlns="http://www.w3.org/2000/svg"></g>');
                    let xwidth = 0;
                    svgcolumn.append(svgback);
                    svgcolumn.append(svgfront);
                    svgcolumn.css('grid-row', '1/span ' + (max.row + 2))
                    svgcolumn.css('grid-column', tcolumns.indexOf(tcolumns.first) + 2);
                    svgcolumn.attr('height', $('#graphcanvas').attr('height'));
                    $('#graphgrid').append(svgcolumn);

                    for (var i = 0; i < max.row; i++) {
                      let node = svgfront.append($(tcolumnsvgs[h][i+1]));
                      if (xwidth < node[0].getBBox().width) { xwidth = node[0].getBBox().width; }
                    }
                    xwidth = xwidth + 2 * space;
                    if (striped == true) {
                      for (var i = 0; i < max.row; i++) {
                        svgback.append($X('<rect xmlns="http://www.w3.org/2000/svg" element-row="' + i + '" class="stripe ' +  (i % 2 == 0 ? 'even' : 'odd') + '" x="0" y="' + (dimensions.height * i + dimensions.height_shift/2) + '" width="' + (xwidth + 1) + '" height="' + dimensions.height + '"></rect>'));
                        svgback.append($X('<rect xmlns="http://www.w3.org/2000/svg" element-row="' + i + '" class="border" x="0" y="' + (dimensions.height * i + dimensions.height_shift/2) + '" height="' + dimensions.height + '" width="1"></rect>'));
                      }
                    }
                    if (tcolumntype[h] == 'resource' || tcolumntype[h] == 'bodsod') {
                      let count = 0;
                      for (const [k, p] of mapPoints) {
                        svgback.append($X('<line xmlns="http://www.w3.org/2000/svg" resource-column="' + count + '" x1="' + (p.x + iconsize/2) + '" y1="' + p.y0 + '" x2="' + (p.x + iconsize/2) + '" y2="' + (p.ymax + 0.01) + '" class="' + tcolumntype[h] + '-column" stroke-width="' + iconsize + '"><text>' + k + '</text></line>'));
                        count += 1;
                      }
                    }

                    $('.resource-label').hide();  // Speech Bubble hide by default

                    svgcolumn.attr('width', xwidth);
                  }
                });

                // Add the last stripe
                var j = tcolumns.length;
                for (var i = 0; i < max.row; i++) {
                  var ele = $('<div element-row="' + i + '" class="graphlast ' + (i % 2 == 0 ? 'odd' : 'even') + '" style="grid-column: ' + (j+2) + '; grid-row: ' + (i+2) + '; height: ' + dimensions.stripe_height + 'px">&#032;</div>');
                  $('#graphgrid').append(ele);
                }
              };
              graphrealization.set_svg_container($('#graphcanvas'));
              graphrealization.set_label_container($('#graphgrid'));
              graphrealization.set_description($(data), true);
            });
          },
        });
      });
    </script>
  </head>
  <body id='graphcolumn'>
    <template id="label">
      <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" style="position: absolute; top: 0; left: 0;" class="displaylabel">
        <g transform="translate(1 %%1) rotate(-%%2)">
          <rect class="displaylabel" width="200" height="14" x="8" y="0" rx="5" ry="5"/>
          <path class="displaylabel" d="M10,13 0,13 8,8"/>
          <path class="displaylabelinner" d="M10,11.5 8.5,11.5 8.5,9.5 10,9.5"/>
          <text class="label" x="18" y="10">aaaa</text>
        </g>
      </svg>
    </template>
    <div id='graphgrid'><svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink" id='graphcanvas' width='1' height='1'></svg></div>
  </body>
</html>
